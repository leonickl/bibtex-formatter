#!/usr/bin/env php
<?php

function dd(mixed ...$values)
{
    var_dump(...$values);
    die;
}

enum State: string
{
    case PARSING = 'PARSING';
    case TYPE = 'TYPE';
    case BODY = 'BODY';
    case KEY = 'KEY';
    case VALUE = 'VALUE';
}

class Parser
{
    private const WHITESPACE = [" ", "\n", "\r", "\t", "\v", "\x00"];

    private State $state = State::PARSING;
    private array $entries = [];
    private ?object $entry = null; 
    private ?object $property = null;
    private array $log = [];
    private int $braceDepth = 0;

    private function __construct(private array $tokens) {}

    public static function read(string $file)
    {
        $raw = @file_get_contents($file);

        if(! $raw) {
            die("File '$file' not found\n");
        }

        $tokens = str_split($raw);

        return new self($tokens);
    }

    public function parse()
    {
        foreach($this->tokens as $token) {
            $this->parseToken($token);
        }

        return $this;
    }

    private function parseToken(string $token)
    {
        $this->log[] = $this->state->value . ':' . json_encode($token) . "($this->braceDepth)";

        if($this->state === State::PARSING) {
            if($token === '@') {
                if($this->entry !== null) {
                    throw new Exception('cannot start new entry when old one is not finished');
                }

                $this->entry = (object)['type' => '', 'name' => '', 'body' => []];
                $this->state = State::TYPE;
                return;
            }

            return;
        }

        if($this->state === State::TYPE) {
            if($token === '{') {
                $this->state = State::BODY;
                return;
            }

            if(in_array($token, self::WHITESPACE)) {
                return;
            }

            if($this->entry === null) {
                throw new Exception('cannot add token to type of null');
            }

            $this->entry->type .= $token;
            return;
        }

        if($this->state === State::BODY) {
            if(in_array($token, self::WHITESPACE)) {
                return;
            }

            if($token === ',') {
                $this->entry->body[] = $this->property;
                $this->property = null;
                $this->state = State::BODY;
                return;
            }

            if($token === '}') {
                $this->entries[] = $this->entry;
                $this->entry = null;
                $this->state = State::PARSING;
                return;
            }

            $this->state = State::KEY;
            $this->property = (object)['key' => '', 'value' => ''];
            $this->parseToken($token);
            return;
        }

        if($this->state === State::KEY) {
            if($this->property === null) {
                throw new Exception('cannot add token to key of property null');
            }
            
            if(in_array($token, self::WHITESPACE)) {
                return;
            }
            
            if($token === ',') {
                $this->entry->name = $this->property->key;
                $this->property = null;
                $this->state = State::BODY;
                return;
            }
            
            if($token === '}') {
                $this->entries[] = $this->entry;
                $this->entry = null;
                $this->state = State::PARSING;
                return;
            }
            
            if($token === '=') {
                $this->state = State::VALUE;
                return;
            }

            $this->property->key .= $token;
            return;
        }

        if($this->state === State::VALUE && $this->braceDepth === 0) {
            if($token === '{') {
                $this->braceDepth ++;
                $this->property->value .= $token;
                return;
            }

            if($token === ',' || $token === '}') {
                $this->state = State::BODY;
                $this->parseToken($token);
                return;
            }

            if(in_array($token, self::WHITESPACE)) {
                return;
            }

            $this->property->value .= $token;

            return;
        }

        if($this->state === State::VALUE && $this->braceDepth > 0) {
            if($token === '{') {
                $this->braceDepth ++;
                $this->property->value .= $token;
                return;
            }

            if($token === '}') {
                $this->braceDepth --;
                $this->property->value .= $token;
                return;
            }

            $this->property->value .= $token;
            return;
        }
    }

    public function sort()
    {
        usort($this->entries, fn($one, $two) => $one->name <=> $two->name);

        foreach($this->entries as &$entry) {
            usort($entry->body, fn($one, $two) => $one->key <=> $two->key);
        }

        return $this;
    }

    public function dump()
    {
        var_dump($this->entries);
    }

    public function log()
    {
        echo implode("\n", $this->log);
    }

    public function print()
    {
        $output = '';

        foreach($this->entries as $entry) {
            $output .= "@{$entry->type}{{$entry->name},\n";

            $maxlen = max(array_map(fn(object $property) => strlen($property->key), $entry->body));

            foreach($entry->body as $property) {
                $key = $property->key.str_repeat(' ', $maxlen - strlen($property->key));

                $output .= "    $key = $property->value,\n";
            }

            $output .= "}\n\n";
        }

        return substr($output, 0, -1);
    }

    public function save(string $file)
    {
        file_put_contents($file, $this->print());
    }
}

$file = @$argv[1];

if(! $file) {
    die("Enter file to be formatted\n");
}

Parser::read($file)
    ->parse()
    ->sort()
    ->save($file);
